３．開発日記

20191218

GF(4096)上定義されたバイナリGoppa符号を生成できるようになった。この計算には14分もかかるので今後何か別の計算方法を考えないといけない。(oplib.cpp)
因みに、QC-MDPCなんで邪道だと思っているので、オリジナルの古典的Goppa符号を使っている。

同時に、LU分解法にヒントを得た可逆スクランブル行列を生成できるようになった。(lu.c)

公開鍵のパラメーターは、[n,k,t]=[4096,2040,85]である。

20191221

GF4096において、型をunsigned shortにして、バイナリ生成行列を出力させる鍵生成まで完成。(oplib.cpp)

20191226

開発メモ。誤りロケータだけは実装完了。バイナリバージョンの場合は誤りの位置を決定するだけで済むのでこれで完成。(chen.c)

既知のバグ：誤りの値を計算するときに、0になる場合がある。これは誤りロケータと、誤り値関数にまだ最小公倍数、つまり
1次式が残されている証拠で、この点を解決するためにユークリッドアルゴリズムに多少の改良を加える必要がある。この点については
来年に目標にしたい。(oplib.c)

20191227

誤りロケータもバグっていることが判明。しかし体力の限界。もう十日近く15時間やってるけど、そろそろ限界。
今のところ一番確実に動くのがchen.cなので、これをもとにバグ取りをしようと思う。でも今年はもうおしまい。
わずか１０００行のプログラムの挙動が理解できない私は低能だｗ

手で計算できないものは計算機を使って計算させてバグ取りをしないといけないし、デバック用のプログラムも書かないといけないのでまた来年。

20191229

バグを最後の1つに絞り込めた。現在デバッグモジュールを作成中。

20191230

ついにバグを突き止めた。生成行列の特定の列が０ベクトルだったという落とし穴がｗ。アルゴリズムは間違いなかった。
どこを探しても問題なかったから、まさかと思って調べてみたら０だったというｗ。しかも１１個もあった。
陽性かくにん、よかった。あとは０のない生成行列をどう作るかで、トレースチェックだけすればいいんじゃないかと思うのだが違うんだろうか？
これでもかなりマシになったほうなのだが、まだ重解を持つ可能性があるので完全にバグがないとは言えない。
とりあえずバイナリの場合は誤り位置だけ正確に計算できればいいので、これで完成しているはず。
あとは実際に公開鍵を使って暗号化復号化をするというIOの部分を作ることになる。あとソースにコメントもつけないといけない。(oplib.c)

20191231

とりあえずバグはなくなったはずなのですが、まだあるかもしれません。そしてこのコードをどういう形で使うのかはまだ決めてません。
PGPのような完璧なアプリを作るのはちょっと荷が重いし、Cの初心者レベルのコードなので興味のある人が最適化したり、もっとエレガントな
コードを書いてくれればいいのですが。とりあえず趣味でやった割にはよくできたと自分を褒めてあげたいですｗ。

20200131

https://csrc.nist.gov/projects/post-quantum-cryptography/round-2-submissions

アメリカのNISTで進んでいる次世代公開鍵暗号の選定、第2ラウンドまでにMcEliece暗号が残っているようです。今の所符号に基づく暗号と講師に基づく暗号が拮抗しているようです。私もアセンブリマクロを使って最適化してみようかな。頑張れMcEliece！

https://klevas.mif.vu.lt/~skersys/vsd/crypto_on_codes/goppamceliece.pdf

入れ知恵になるかもしれないですがこれも参考にしてみたいと思います。どうも外部ライブラリを使った実装ばかりで私みたいに一枚岩の自己完結プログラムがないようで。


20200202

https://en.wikipedia.org/wiki/Binary_Goppa_code#Decoding

これのおかげでやっとパターソンアルゴリズムを理解できた。シンドローム多項式の逆多項式はゴッパ多項式が既約のとき、ユークリッドアルゴリズムで
計算できる。そしてバイナリGoppa符号の場合、符号長は変わらず次元だけが縦に引き伸ばされるので、シンドローム多項式は拡大体のときと同じ多項式である。
このとき逆多項式とその平方が計算できるので、解くべき誤り位置関数の次数はシンドローム多項式の半分になる。だから拡大体のときより
Goppa多項式の次数は半分で済む。ということはバイナリバージョンを作らなければならない。やる気が出たらやろう。

http://lupus.is.kochi-u.ac.jp/shiota/misc/field/FiniteField.html

あとgithubにはなかったけれど、プロが書いたMcEliece暗号のデモがあって、エレガントに64ビットに最適化されていて鍵生成はものすごく早かった。
本来ならこうあるべきだけど自分にはその実力がない。

まだ理解があやふやな部分があるので、ｔ個のエラーを訂正するのにｔ次規約多項式の自乗を使ってｔ個のエラーを訂正すれば今の方法を変更しなくても
済むだろうと思った。Goppa多項式の次数は半分に減るので結果は同じだ。アルゴリズムを保ったまま秘密多項式の次数を下げられる。


20200209

https://digitalcommons.csbsju.edu/cgi/viewcontent.cgi?article=1019&context=honors_theses

これもすごい。

20200222

パターソンアルゴリズムを完全実装しました。このアルゴリズムの実現のために多項式の平方根を計算する関数などを追加しました。
我ながらいい感じで使えているのでよかったと思います。ほかの人が満足するかわかりませんがｗ。このアルゴリズムによって、
ｔ次の多項式に対してt個のバイナリエラーが訂正できます。できるかどうかわかりませんでしたができました。(polib.c)

20200227

いよいよコードレビュー。まだomodとかの終了条件を理解してないのでそこから始めることになる。インデントとかは後回しになるかも。
パラメータを変更した。変更後のパラメータは[n,k,t]=[6688,3328,256]である。

アルゴリズムの検証作業に入ります。元ネタはここー＞

https://github.com/davidhoo1988/Code_Based_Cryptography_Python

こういうのがあったんだけど古くて動かない。GF2で既約な多項式を見つけるのは早いけど、拡大体上で既約な多項式を見つけるのは
とても遅い。なので、やはりランダムに取ってきて使える鍵だけを使うほうが早い気がする。正攻法より効率的かも。

20200228

文献の追加。バグトラップを仕掛けてバグを見つけています。ユークリッドの方はほぼ完璧なんですが、パターソンアルゴリズムでエラーロケーター
が計算できたり出来なかったりしているバグを見つけて修正方法を考えています。既約多項式なら完全なので、先に正しい鍵を用意するのが早いのかも
しれませんが、もしそれでだめだったらアルゴリズムのバグですね。
でも拡大体上で既約多項式を見つけるのはsagemathでもすごく時間がかかるので悩んでいます。

https://www.hyperelliptic.org/tanja/students/m_marcus/whitepaper.pdf

20200229

バグが取れた。基本計算は完成したので、これから電子署名と暗号通貨を作ります。

https://classic.mceliece.org/

20200303

今日は暗号化関数の前処理としてハッシュ関数の他の人が書いた使えそうなリポジトリを探してコピーして改ざんした。
SHA3を使う予定。OAEP処理するため。

20200304

サブフォルダdecomp内の、分割コンパイルできるように切り離されたソースと簡単なMakefileを置き換えた。
更にハッシュ関数としてsha3を他のリポジトリからcloneして暗号化関数に使用した。
main関数の中にあったシンドローム計算のための処理を関数に分離した。
私がこれでいいんだからこれでいいのだ。
今の所実用レベルのパラメータを実装したものは見当たらない。解読されているような少し昔の方式があるだけだ。
これが気に入らないというなら自分で論文を読んで1から書くか、改造すればいいだけであって分割コンパイルもインデントも私は必要としていない。
暗号化ができればそれでいいのだ。そういうことができるプロもいるだろうからその人の実装を待てばいい。

20200305

512ビットの秘密鍵を暗号化復号化できるようになった。後はファイルやバッファも暗号化できるようにしたい。
バイナリ公開鍵は半分しか作ってないので、それも完成させる必要があるけど、今はこれで十分な気がする。

OAEP処理のつもりですが、encrypt関数でランダムエラーにハッシュをかけて、そのハッシュ値を64バイトの鍵データにXORします。
続けて、エンダムエラーを符号化してそのシンドロームをファイルに出力します。このファイル名は、enc.skです。
復号化はdecrypt関数です。もっとわかりやすくしないといけないですね。新しい関数を作ることばかりで、全然保守してない。
マイペースｗ。

20200306

蛇足かもしれないけどファイルの暗号化復号化の関数を作った。
復元したエラーベクトルにハッシュ関数をかけて、そのハッシュ値をファイルのデータにXORして暗号化する公開鍵/秘密鍵のコンパチブル関数。
暗号化の方法ですが、プログラムの中でfileenc()関数やfiledec関数を呼び出して、実行時に

./a.out file1 file2 file3

とやるとfile1に暗号化したいファイル名、file2に暗号化後のファイル名、file3に復号後のファイル名でテストできます。

一応ライブラリみたいな感じにしたいので、使い方についてはもう少し詳しく書く予定です。
マニュアルみたいなことをここに書くべきかと。もっと詳しい人が見れば、十分な暗号化にはなっていない可能性があります。
エディタでみると記号みたいなものが出てくるので、完全に砂のようにランダム化されていない感じがします。

